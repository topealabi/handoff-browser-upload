"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const exists_1 = require("./util/exists");
const deferred_1 = require("./util/deferred");
const ListLogSummary_1 = require("./responses/ListLogSummary");
const debug = require('debug')('simple-git');
const NOOP = () => { };
/**
 * Git handling for node. All public functions can be chained and all `then` handlers are optional.
 *
 * @param {string} baseDir base directory for all processes to run
 *
 * @param {Object} ChildProcess The ChildProcess module
 * @param {Function} Buffer The Buffer implementation to use
 *
 * @constructor
 */
class Git {
    constructor(_baseDir, ChildProcess, Buffer) {
        this._baseDir = _baseDir;
        this.ChildProcess = ChildProcess;
        this.Buffer = Buffer;
        this._runCache = [];
        /**
         * @type {string} The command to use to reference the git binary
         */
        this._command = 'git';
        /**
         * An object of key=value pairs to be passed as environment variables to the spawned child process.
         */
        this._env = null;
        /**
         * @type {Function} An optional handler to use when a child process is created
         */
        this._outputHandler = null;
        /**
         * @type {boolean} Property showing whether logging will be silenced - defaults to true in a production environment
         */
        this._silentLogging = true;
        this._silentLogging = /prod/.test(process.env.NODE_ENV);
    }
    /**
     * Marks the git instance as having had a fatal exception by clearing the pending queue of tasks and
     * logging to the console.
     *
     * @param git
     * @param error
     * @param callback
     */
    static exception(git, error, callback) {
        git._runCache.length = 0;
        if (typeof callback === 'function') {
            callback(error instanceof Error ? error : new Error(error));
        }
        git._getLog('error', error);
    }
    ;
    /**
     * Handles an exception in the processing of a command.
     */
    static fail(git, error, handler) {
        git._getLog('error', error);
        git._runCache.length = 0;
        if (typeof handler === 'function') {
            handler(error, null);
        }
    }
    /**
     * Gets a function to be used for logging.
     *
     * @param {string} level
     * @param {string} [message]
     *
     * @returns {Function}
     * @private
     */
    _getLog(level, message) {
        if (this._silentLogging) {
            return NOOP;
        }
        const log = (...args) => console[level](...args);
        if (arguments.length > 1) {
            log(message);
        }
        return log;
    }
    ;
    /**
     * Schedules the supplied command to be run, the command should not include the name of the git binary and should
     * be an array of strings passed as the arguments to the git binary.
     *
     * @param {string[]} command
     * @param {Function} then
     * @param {Object} [opt]
     * @param {boolean} [opt.concatStdErr=false] Optionally concatenate stderr output into the stdout
     * @param {boolean} [opt.format="utf-8"] The format to use when reading the content of stdout
     * @param {Function} [opt.onError] Optional error handler for this command - can be used to allow non-clean exits
     *                                  without killing the remaining stack of commands
     * @param {number} [opt.onError.exitCode]
     * @param {string} [opt.onError.stdErr]
     *
     * @returns {Git}
     */
    _run(command, then, opt) {
        // if (typeof command === 'string') {
        // TODO: DEPRECATE PATH BY 2.5.0
        // command = command.split(' ');
        // }
        this._runCache.push([command, then, opt || {}]);
        this._schedule();
        return this;
    }
    _schedule() {
        if (this._childProcess || !this._runCache.length) {
            return;
        }
        const git = this;
        const Buffer = git.Buffer;
        const task = git._runCache.shift();
        const [command, then, options] = task;
        debug(command);
        const result = deferred_1.deferred();
        const stdOut = [];
        const stdErr = [];
        const spawned = git.ChildProcess.spawn(git._command, command.slice(0), {
            cwd: git._baseDir,
            env: git._env
        });
        spawned.stdout.on('data', (buffer) => stdOut.push(buffer));
        spawned.stderr.on('data', (buffer) => stdErr.push(buffer));
        spawned.on('error', (err) => stdErr.push(new Buffer(err.stack, 'ascii')));
        spawned.on('close', result.resolve);
        spawned.on('exit', result.resolve);
        result.promise.then((exitCode) => {
            const done = (output) => then.call(this, null, output);
            const fail = (error) => Git.fail(this, error, then);
            this._childProcess = null;
            if (exitCode && stdErr.length && options.onError) {
                options.onError(exitCode, Buffer.concat(stdErr).toString('utf-8'), done, fail);
            }
            else if (exitCode && stdErr.length) {
                fail(Buffer.concat(stdErr).toString('utf-8'));
            }
            else {
                if (options.concatStdErr) {
                    stdOut.push(...stdErr);
                }
                let stdOutput = Buffer.concat(stdOut);
                if (options.format !== 'buffer') {
                    stdOutput = stdOutput.toString(options.format || 'utf-8');
                }
                done(stdOutput);
            }
            process.nextTick(() => this._schedule());
        });
        git._childProcess = spawned;
        if (git._outputHandler) {
            git._outputHandler(command[0], git._childProcess.stdout, git._childProcess.stderr);
        }
    }
    /**
     * Sets the path to a custom git binary, should either be `git` when there is an installation of git available on
     * the system path, or a fully qualified path to the executable.
     *
     * @param {string} command
     * @returns {Git}
     */
    customBinary(command) {
        this._command = command;
        return this;
    }
    /**
     * Sets an environment variable for the spawned child process, either supply both a name and value as strings or
     * a single object to entirely replace the current environment variables.
     *
     * @param {string|Object} name
     * @param {string} [value]
     * @returns {Git}
     */
    env(name, value) {
        if (arguments.length === 1 && typeof name === 'object') {
            this._env = name;
        }
        else {
            (this._env = this._env || {})[name] = value;
        }
        return this;
    }
    /**
     * Sets the working directory of the subsequent commands.
     *
     * @param {string} workingDirectory
     * @param {Function} [then]
     * @returns {Git}
     */
    cwd(workingDirectory, then) {
        const next = trailingFunctionArgument(arguments);
        return this.exec(() => {
            this._baseDir = workingDirectory;
            if (!exists_1.exists(workingDirectory, exists_1.FOLDER)) {
                Git.exception(this, `Git.cwd: cannot change to non-directory ${workingDirectory}"`, next);
            }
            else {
                next && next(null, workingDirectory);
            }
        });
    }
    /**
     * Call a simple function at the next step in the chain.
     * @param {Function} [then]
     */
    exec(then) {
        this._run([], function () {
            typeof then === 'function' && then();
        });
        return this;
    }
    /**
     * Initialize a git repo
     *
     * @param {Boolean} [bare=false]
     * @param {Function} [then]
     */
    init(bare = false, then) {
        const commands = ['init'];
        if (bare === true) {
            commands.push('--bare');
        }
        return this._run(commands, trailingFunctionArgument(arguments) || NOOP);
    }
    /**
     * Check the status of the local repo
     *
     * @param {Function} [then]
     */
    status(then) {
        return this._run(['status', '--porcelain', '-b', '-u'], responseHandler(then, 'StatusSummary'));
    }
    /**
     * Sets a handler function to be called whenever a new child process is created, the handler function will be called
     * with the name of the command being run and the stdout & stderr streams used by the ChildProcess.
     *
     * @example
     * require('simple-git')
     *    .outputHandler(function (command, stdout, stderr) {
     *       stdout.pipe(process.stdout);
     *    })
     *    .checkout('https://github.com/user/repo.git');
     *
     * @see http://nodejs.org/api/child_process.html#child_process_class_childprocess
     * @see http://nodejs.org/api/stream.html#stream_class_stream_readable
     * @param {Function} outputHandler
     * @returns {Git}
     */
    outputHandler(outputHandler) {
        this._outputHandler = outputHandler;
        return this;
    }
    /**
     * List the stash(s) of the local repo
     *
     * @param {Object|Array} [options]
     * @param {Function} [then]
     */
    stashList(options, then) {
        const next = trailingFunctionArgument(arguments);
        const opt = trailingOptionsArgument(arguments) || trailingArrayArgument(arguments) || {};
        const splitter = opt.hasOwnProperty('splitter') ? opt.splitter : ';';
        const command = ['stash', 'list', '--pretty=format:%H %ai %s%d %aN %ae'.replace(/\s+/g, splitter)];
        if (Array.isArray(opt)) {
            command.push(...opt);
        }
        return this._run(command, responseHandler(next, 'ListLogSummary', splitter));
    }
    /**
     * Stash the local repo
     *
     * @param {Object|Array} [options]
     * @param {Function} [then]
     */
    stash(options, then) {
        const next = trailingFunctionArgument(arguments);
        const command = ['stash'];
        if (Array.isArray(options)) {
            command.push(...options);
        }
        else {
            appendOptions(command, trailingOptionsArgument(arguments));
        }
        return this._run(command, next || NOOP);
    }
    /**
     * Clone a git repo
     *
     * @param {string} repoPath
     * @param {string} localPath
     * @param {String[]} [options] Optional array of options to pass through to the clone command
     * @param {Function} [then]
     */
    clone(repoPath, localPath, options, then) {
        const next = trailingFunctionArgument(arguments) || NOOP;
        const command = ['clone', ...trailingArrayArgument(arguments)];
        for (let i = 0, iMax = arguments.length; i < iMax; i++) {
            if (typeof arguments[i] === 'string') {
                command.push(arguments[i]);
            }
        }
        return this._run(command, next);
    }
    /**
     * Mirror a git repo
     *
     * @param {string} repoPath
     * @param {string} localPath
     * @param {Function} [then]
     */
    mirror(repoPath, localPath, then) {
        return this.clone(repoPath, localPath, ['--mirror'], then);
    }
    /**
     * Moves one or more files to a new destination.
     *
     * @see https://git-scm.com/docs/git-mv
     *
     * @param {string|string[]} from
     * @param {string} to
     * @param {Function} [then]
     */
    mv(from, to, then) {
        const next = trailingFunctionArgument(arguments);
        const command = ['mv', '-v', ...[].concat(from), to];
        this._run(command, responseHandler(next, 'MoveSummary'));
    }
    /**
     * Internally uses pull and tags to get the list of tags then checks out the latest tag.
     *
     * @param {Function} [then]
     * @deprecated Will be removed in a future version, please use `checkout` directly
     */
    checkoutLatestTag(then) {
        return this.pull().tags((err, tags) => this.checkout(tags.latest, then));
    }
    /**
     * Adds one or more files to source control
     *
     * @param {string|string[]} files
     * @param {Function} [then]
     */
    add(files, then) {
        return this._run(['add'].concat(files), trailingFunctionArgument(arguments) || NOOP);
    }
    /**
     * Commits changes in the current working directory - when specific file paths are supplied, only changes on those
     * files will be committed.
     *
     * @param {string|string[]} message
     * @param {string|string[]} [files]
     * @param {Object} [options]
     * @param {Function} [then]
     */
    commit(message, files, options, then) {
        const next = trailingFunctionArgument(arguments);
        const command = ['commit'];
        [].concat(message).forEach((message) => command.push('-m', message));
        command.push(...asArray(typeof files === 'string' || Array.isArray(files) ? files : []));
        appendOptions(command, trailingOptionsArgument(arguments));
        return this._run(command, responseHandler(next, 'CommitSummary'));
    }
    /**
     * Pull the updated contents of the current repo
     *
     * @param {string} [remote] When supplied must also include the branch
     * @param {string} [branch] When supplied must also include the remote
     * @param {Object} [options] Optionally include set of options to merge into the command
     * @param {Function} [then]
     */
    pull(remote, branch, options, then) {
        const command = ['pull'];
        const next = trailingFunctionArgument(arguments);
        if (typeof remote === 'string' && typeof branch === 'string') {
            command.push(remote, branch);
        }
        appendOptions(command, trailingOptionsArgument(arguments));
        return this._run(command, responseHandler(next, 'PullSummary'));
    }
    /**
     * Fetch the updated contents of the current repo.
     *
     * @example
     *   .fetch('upstream', 'master') // fetches from master on remote named upstream
     *   .fetch(function () {}) // runs fetch against default remote and branch and calls function
     */
    fetch(remote, branch, options, then) {
        const command = ['fetch'];
        const next = trailingFunctionArgument(arguments);
        appendOptions(command, trailingOptionsArgument(arguments));
        if (typeof remote === 'string' && typeof branch === 'string') {
            command.push(remote, branch);
        }
        if (Array.isArray(remote)) {
            command.push(...remote);
        }
        return this._run(command, responseHandler(next, 'FetchSummary'), { concatStdErr: true });
    }
    /**
     * Disables/enables the use of the console for printing warnings and errors, by default messages are not shown in
     * a production environment.
     *
     * @param {boolean} silence
     * @returns {Git}
     */
    silent(silence) {
        this._silentLogging = !!silence;
        return this;
    }
    /**
     * List all tags. When using git 2.7.0 or above, include an options object with `"--sort": "property-name"` to
     * sort the tags by that property instead of using the default semantic versioning sort.
     *
     * Note, supplying this option when it is not supported by your Git version will cause the operation to fail.
     *
     * @param {Object} [options]
     * @param {Function} [then]
     */
    tags(options, then) {
        const next = trailingFunctionArgument(arguments);
        const command = ['-l'];
        appendOptions(command, trailingOptionsArgument(arguments));
        const hasCustomSort = command.some(option => /^--sort=/.test(option));
        return this.tag(command, responseHandler(next, 'TagList', hasCustomSort));
    }
    /**
     * Rebases the current working copy. Options can be supplied either as an array of string parameters
     * to be sent to the `git rebase` command, or a standard options object.
     *
     * @param {Object|String[]} [options]
     * @param {Function} [then]
     * @returns {Git}
     */
    rebase(options, then) {
        const command = ['rebase'];
        appendOptions(command, trailingOptionsArgument(arguments));
        command.push(...trailingArrayArgument(arguments));
        return this._run(command, trailingFunctionArgument(arguments) || NOOP);
    }
    /**
     * Reset a repo
     *
     * @param {string|string[]} [mode=soft] Either an array of arguments supported by the 'git reset' command, or the
     *                                        string value 'soft' or 'hard' to set the reset mode.
     * @param {Function} [then]
     */
    reset(mode, then) {
        const command = ['reset'];
        const defaultResetMode = 'soft';
        if (typeof mode === 'undefined' || typeof mode === 'function') {
            command.push(`--${defaultResetMode}`);
        }
        else if (typeof mode === 'string') {
            command.push('--' + (['mixed', 'soft', 'hard'].includes(mode) ? mode : defaultResetMode));
        }
        command.push(...trailingArrayArgument(arguments));
        return this._run(command, trailingFunctionArgument(arguments) || NOOP);
    }
    ;
    /**
     * Revert one or more commits in the local working copy
     *
     * @param {string} commit The commit to revert. Can be any hash, offset (eg: `HEAD~2`) or range (eg: `master~5..master~2`)
     * @param {Object} [options] Optional options object
     * @param {Function} [then]
     */
    revert(commit, options, then) {
        const next = trailingFunctionArgument(arguments) || NOOP;
        const command = ['revert'];
        appendOptions(command, trailingOptionsArgument(arguments));
        command.push(commit);
        return validateArgumentType(this, next, 'revert', commit, 'commit') || this._run(command, function (err) {
            next && next(err || null);
        });
    }
    /**
     * Add a lightweight tag to the head of the current branch
     *
     * @param {string} name
     * @param {Function} [then]
     */
    addTag(name, then) {
        return validateArgumentType(this, then, 'addTag', name, 'name') || this.tag([name], then);
    }
    /**
     * Add an annotated tag to the head of the current branch
     *
     * @param {string} tagName
     * @param {string} tagMessage
     * @param {Function} [then]
     */
    addAnnotatedTag(tagName, tagMessage, then) {
        return this.tag(['-a', '-m', tagMessage, tagName], function (err) {
            then && then(err);
        });
    }
    /**
     * Check out a tag or revision, any number of additional arguments can be passed to the `git checkout` command
     * by supplying either a string or array of strings as the `what` parameter.
     *
     * @param {string|string[]} what One or more commands to pass to `git checkout`
     * @param {Function} [then]
     */
    checkout(what, then) {
        return this._run(['checkout'].concat(what), trailingFunctionArgument(arguments) || NOOP);
    }
    /**
     * Check out a remote branch
     *
     * @param {string} branchName name of branch
     * @param {string} startPoint (e.g origin/development)
     * @param {Function} [then]
     */
    checkoutBranch(branchName, startPoint, then) {
        return this.checkout(['-b', branchName, startPoint], then);
    }
    /**
     * Check out a local branch
     *
     * @param {string} branchName of branch
     * @param {Function} [then]
     */
    checkoutLocalBranch(branchName, then) {
        return this.checkout(['-b', branchName], then);
    }
    /**
     * Delete a local branch
     *
     * @param {string} branchName name of branch
     * @param {Function} [then]
     */
    deleteLocalBranch(branchName, then) {
        return this.branch(['-d', branchName], then);
    }
    /**
     * List all branches
     *
     * @param {Object | string[]} [options]
     * @param {Function} [then]
     */
    branch(options, then) {
        const next = trailingFunctionArgument(arguments);
        const command = ['branch'];
        if (Array.isArray(options)) {
            command.push.apply(command, options);
        }
        appendOptions(command, trailingOptionsArgument(arguments));
        if (!arguments.length || (arguments[0] === next)) {
            command.push('-a', '-v');
        }
        const isDelete = ['-d', '-D', '--delete'].reduce(function (isDelete, flag) {
            return isDelete || command.indexOf(flag) > 0;
        }, false);
        const handler = isDelete
            ? responseHandler(next, 'BranchDeleteSummary', false)
            : responseHandler(next, 'BranchSummary');
        return this._run(command, handler);
    }
    /**
     * Return list of local branches
     *
     * @param {Function} [then]
     */
    branchLocal(then) {
        return this.branch(['-v'], then);
    }
    /**
     * Add config to local git instance
     *
     * @param {string} key configuration key (e.g user.name)
     * @param {string} value for the given key (e.g your name)
     * @param {Function} [then]
     */
    addConfig(key, value, then) {
        return this._run(['config', '--local', key, value], function (err, data) {
            then && then(err, !err && data);
        });
    }
    /**
     * Executes any command against the git binary.
     *
     * @param {string[]|Object} commands
     * @param {Function} [then]
     *
     * @returns {Git}
     */
    raw(commands, then) {
        const next = trailingFunctionArgument(arguments) || NOOP;
        const command = [];
        if (Array.isArray(commands)) {
            command.push(...commands);
        }
        appendOptions(command, trailingOptionsArgument(arguments));
        if (!command.length) {
            return this.exec(() => next(new Error('Raw: must supply one or more command to execute'), null));
        }
        return this._run(command, next);
    }
    /**
     * Add a submodule
     *
     * @param {string} repo
     * @param {string} path
     * @param {Function} [then]
     */
    submoduleAdd(repo, path, then) {
        return this._run(['submodule', 'add', repo, path], trailingFunctionArgument(arguments) || NOOP);
    }
    /**
     * Update submodules
     *
     * @param {string[]} [args]
     * @param {Function} [then]
     */
    submoduleUpdate(args, then) {
        const next = trailingFunctionArgument(arguments) | NOOP;
        return validateArgumentType(this, next, 'submoduleUpdate', args, 'args', 'array') ||
            this.subModule(['update', ...trailingArrayArgument(arguments)], next);
    }
    /**
     * Initialize submodules
     *
     * @param {string[]} [args]
     * @param {Function} [then]
     */
    submoduleInit(args, then) {
        const next = trailingFunctionArgument(arguments) | NOOP;
        return validateArgumentType(this, next, 'submoduleInit', args, 'args', 'array') ||
            this.subModule(['init', ...trailingArrayArgument(arguments)], next);
    }
    /**
     * Call any `git submodule` function with arguments passed as an array of strings.
     *
     * @param {string[]} options
     * @param {Function} [then]
     */
    subModule(options, then) {
        const next = trailingFunctionArgument(arguments) | NOOP;
        const validation = validateArgumentType(this, next, 'subModule', options, 'options', 'array');
        if (validation) {
            return validation;
        }
        if (options[0] !== 'submodule') {
            options.unshift('submodule');
        }
        return this._run(options, next);
    }
    /**
     * List remote
     *
     * @param {string[]} [args]
     * @param {Function} [then]
     */
    listRemote(args, then) {
        let validation;
        const next = trailingFunctionArgument(arguments) || NOOP;
        if (next === NOOP && arguments.length > 0) {
            validation = validateArgumentType(this, next, 'listRemote', args, 'args', 'array');
        }
        return validation || this._run(['ls-remote', ...trailingArrayArgument(arguments)], next);
    }
    /**
     * Adds a remote to the list of remotes.
     *
     * @param {string} remoteName Name of the repository - eg "upstream"
     * @param {string} remoteRepo Fully qualified SSH or HTTP(S) path to the remote repo
     * @param {Function} [then]
     * @returns {*}
     */
    addRemote(remoteName, remoteRepo, then) {
        return this._run(['remote', 'add', remoteName, remoteRepo], then || NOOP);
    }
    /**
     * Removes an entry from the list of remotes.
     *
     * @param {string} remoteName Name of the repository - eg "upstream"
     * @param {Function} [then]
     * @returns {*}
     */
    removeRemote(remoteName, then) {
        return this._run(['remote', 'remove', remoteName], then || NOOP);
    }
    /**
     * Gets the currently available remotes, setting the optional verbose argument to true includes additional
     * detail on the remotes themselves.
     *
     * @param {boolean} [verbose=false]
     * @param {Function} [then]
     */
    getRemotes(verbose = false, then) {
        const next = trailingFunctionArgument(arguments);
        const args = verbose === true ? ['-v'] : [];
        return this.remote(args, function (err, data) {
            next && next(err, !err && function () {
                return data.trim().split('\n').filter(Boolean).reduce(function (remotes, remote) {
                    var detail = remote.trim().split(/\s+/);
                    var name = detail.shift();
                    if (!remotes[name]) {
                        remotes[name] = remotes[remotes.length] = {
                            name: name,
                            refs: {}
                        };
                    }
                    if (detail.length) {
                        remotes[name].refs[detail.pop().replace(/[^a-z]/g, '')] = detail.pop();
                    }
                    return remotes;
                }, []).slice(0);
            }());
        });
    }
    /**
     * Call any `git remote` function with arguments passed as an array of strings.
     *
     * @param {string[]} options
     * @param {Function} [then]
     */
    remote(options, then) {
        const next = trailingFunctionArgument(arguments) | NOOP;
        const validation = validateArgumentType(this, next, 'remote', options, 'options', 'array');
        if (validation) {
            return validation;
        }
        if (options[0] !== 'remote') {
            options.unshift('remote');
        }
        return this._run(options, function (err, data) {
            then && then(err || null, err ? null : data);
        });
    }
    /**
     * Merges from one branch to another, equivalent to running `git merge ${from} $[to}`, the `options` argument can
     * either be an array of additional parameters to pass to the command or null / omitted to be ignored.
     *
     * @param {string} from
     * @param {string} to
     * @param {string[]} [options]
     * @param {Function} [then]
     */
    mergeFromTo(from, to, options, then) {
        return this.merge([from, to, ...trailingArrayArgument(arguments)], trailingFunctionArgument(arguments));
    }
    /**
     * Runs a merge, `options` can be either an array of arguments
     * supported by the [`git merge`](https://git-scm.com/docs/git-merge)
     * or an options object.
     *
     * Conflicts during the merge result in an error response,
     * the response type whether it was an error or success will be a MergeSummary instance.
     * When successful, the MergeSummary has all detail from a the PullSummary
     *
     * @param {Object | string[]} [options]
     * @param {Function} [then]
     * @returns {*}
     *
     * @see ./responses/MergeSummary.js
     * @see ./responses/PullSummary.js
     */
    merge(options, then) {
        const next = trailingFunctionArgument(arguments) || NOOP;
        const mergeHandler = (err, mergeSummary) => {
            if (!err && mergeSummary.failed) {
                return Git.fail(this, mergeSummary, next);
            }
            next(err, mergeSummary);
        };
        const command = [];
        appendOptions(command, trailingOptionsArgument(arguments));
        command.push(...trailingArrayArgument(arguments));
        if (command[0] !== 'merge') {
            command.unshift('merge');
        }
        if (command.length === 1) {
            return this.exec(() => then(new TypeError('Git.merge requires at least one option')));
        }
        return this._run(command, responseHandler(mergeHandler, 'MergeSummary'), { concatStdErr: true });
    }
    /**
     * Call any `git tag` function with arguments passed as an array of strings.
     *
     * @param {string[]} options
     * @param {Function} [then]
     */
    tag(options, then) {
        const next = trailingFunctionArgument(arguments) | NOOP;
        const validation = validateArgumentType(this, next, 'tag', options, 'options', 'array');
        if (validation) {
            return validation;
        }
        if (options[0] !== 'tag') {
            options.unshift('tag');
        }
        return this._run(options, next);
    }
    /**
     * Updates repository server info
     *
     * @param {Function} [then]
     */
    updateServerInfo(then) {
        return this._run(['update-server-info'], then || NOOP);
    }
    /**
     * Pushes the current committed changes to a remote, optionally specify the names of the remote and branch to use
     * when pushing. Supply multiple options as an array of strings in the first argument - see examples below.
     *
     * @param {string|string[]} [remote]
     * @param {string} [branch]
     * @param {Function} [then]
     */
    push(remote, branch, then) {
        const next = trailingFunctionArgument(arguments) || NOOP;
        const command = [];
        if (typeof remote === 'string' && typeof branch === 'string') {
            command.push(remote, branch);
        }
        if (Array.isArray(remote)) {
            command.push(...remote);
        }
        appendOptions(command, trailingOptionsArgument(arguments));
        if (command[0] !== 'push') {
            command.unshift('push');
        }
        return this._run(command, function (err, data) {
            next && next(err, !err && data);
        });
    }
    /**
     * Pushes the current tag changes to a remote which can be either a URL or named remote. When not specified uses the
     * default configured remote spec.
     *
     * @param {string} [remote]
     * @param {Function} [then]
     */
    pushTags(remote, then) {
        const command = ['push'];
        if (typeof remote === 'string') {
            command.push(remote);
        }
        command.push('--tags');
        return this._run(command, trailingFunctionArgument(arguments) || NOOP);
    }
    /**
     * Removes the named files from source control.
     *
     * @param {string|string[]} files
     * @param {Function} [then]
     */
    rm(files, then) {
        return this._rm(files, '-f', then);
    }
    /**
     * Removes the named files from source control but keeps them on disk rather than deleting them entirely. To
     * completely remove the files, use `rm`.
     *
     * @param {string|string[]} files
     * @param {Function} [then]
     */
    rmKeepLocal(files, then) {
        return this._rm(files, '--cached', then);
    }
    /**
     * Returns a list of objects in a tree based on commit hash. Passing in an object hash returns the object's content,
     * size, and type.
     *
     * Passing "-p" will instruct cat-file to determine the object type, and display its formatted contents.
     *
     * @param {string[]} [options]
     * @param {Function} [then]
     */
    catFile(options, then) {
        return this._catFile('utf-8', ...arguments);
    }
    /**
     * Equivalent to `catFile` but will return the native `Buffer` of content from the git command's stdout.
     *
     * @param {string[]} options
     * @param then
     */
    binaryCatFile(options, then) {
        return this._catFile('buffer', ...arguments);
    }
    _catFile(format, options, then) {
        const next = trailingFunctionArgument(arguments) || NOOP;
        const command = ['cat-file', ...trailingArrayArgument(arguments)];
        return this._run(command, next, { format: format });
    }
    /**
     * Return repository changes.
     *
     * @param {string[]} [options]
     * @param {Function} [then]
     */
    diff(options, then) {
        const next = trailingFunctionArgument(arguments) || NOOP;
        let validation;
        if (next !== arguments[0]) {
            validation = validateArgumentType(this, next, 'diff', options, 'options', 'array');
        }
        return validation || this._run(['diff', trailingArrayArgument(arguments)], next);
    }
    diffSummary(options, then) {
        const next = trailingFunctionArgument(arguments) || NOOP;
        const command = ['--stat=4096'];
        if (typeof options === 'string' || Array.isArray(options)) {
            command.push.apply(command, [].concat(options));
        }
        return this.diff(command, responseHandler(next, 'DiffSummary'));
    }
    /**
     * Wraps `git rev-parse`. Primarily used to convert friendly commit references (ie branch names) to SHA1 hashes.
     *
     * Options should be an array of string options compatible with the `git rev-parse`
     *
     * @param {string[]} [options]
     * @param {Function} [then]
     *
     * @see http://git-scm.com/docs/git-rev-parse
     */
    revparse(options, then) {
        const next = trailingFunctionArgument(arguments) || NOOP;
        let validation;
        if (arguments.length && arguments[0] !== next) {
            validation = validateArgumentType(this, next, 'revparse', options, 'options', 'array');
        }
        return validation || this._run(['rev-parse', ...trailingArrayArgument(arguments)], next);
    }
    /**
     * Show various types of objects, for example the file at a certain commit
     *
     * @param {string[]} [options]
     * @param {Function} [then]
     */
    show(options, then) {
        const next = trailingFunctionArgument(arguments) || NOOP;
        let validation;
        if (arguments.length && arguments[0] !== next) {
            validation = validateArgumentType(this, next, 'show', options, 'options', 'array');
        }
        return validation || this._run(['show', ...trailingArrayArgument(arguments)], next);
    }
    /**
     * @param {string} mode Required parameter "n" or "f"
     * @param {string[]} options
     * @param {Function} [then]
     */
    clean(mode, options, then) {
        const next = trailingFunctionArgument(arguments) || NOOP;
        let validation = validateArgumentType(this, next, 'clean', mode, 'mode', 'string');
        validation = validation || (!/[nf]/.test(mode) && this.exec(() => Git.fail(this, new TypeError(`Git.clean mode parameter ("n" or "f") is required`), next)));
        validation = validation || (!/[^dfinqxX]/.test(mode) && this.exec(() => Git.fail(this, new TypeError(`Git.clean unknown option found in ${mode}`), next)));
        if (validation) {
            return validation;
        }
        const command = ['clean', `-${mode}`, ...trailingArrayArgument(arguments)];
        if (command.some(interactiveMode)) {
            return this.exec(() => Git.fail(this, new TypeError(`Git clean interactive mode is not supported`), next));
        }
        return this._run(command, next);
        function interactiveMode(option) {
            if (/^-[^\-]/.test(option)) {
                return option.indexOf('i') > 0;
            }
            return option === '--interactive';
        }
    }
    /**
     * Show commit logs from `HEAD` to the first commit.
     * If provided between `options.from` and `options.to` tags or branch.
     *
     * Additionally you can provide options.file, which is the path to a file in your repository. Then only this file will be considered.
     *
     * To use a custom splitter in the log format, set `options.splitter` to be the string the log should be split on.
     *
     * Options can also be supplied as a standard options object for adding custom properties supported by the git log command.
     * For any other set of options, supply options as an array of strings to be appended to the git log command.
     *
     * @param {Object|string[]} [options]
     * @param {string} [options.from] The first commit to include
     * @param {string} [options.to] The most recent commit to include
     * @param {string} [options.file] A single file to include in the result
     *
     * @param {Function} [then]
     */
    log(options, then) {
        const next = trailingFunctionArgument(arguments) || NOOP;
        const opt = trailingOptionsArgument(arguments) || {};
        const splitter = opt.splitter || ';';
        const format = opt.format || {
            hash: '%H',
            date: '%ai',
            message: '%s%d',
            author_name: '%aN',
            author_email: '%ae'
        };
        const fields = Object.keys(format);
        const formatStr = fields.map(k => format[k]).join(splitter);
        const command = ['log', `--pretty=format:${formatStr}${ListLogSummary_1.COMMIT_BOUNDARY}`, ...trailingArrayArgument(arguments)];
        if (typeof arguments[0] === 'string' || typeof arguments[1] === 'string') {
            return this.exec(() => Git.fail(this, new TypeError(`Git.log requires string arrays or command objects`), next));
        }
        if (opt.n || opt['max-count']) {
            command.push('--max-count=' + (opt.n || opt['max-count']));
        }
        if (opt.from && opt.to) {
            command.push(opt.from + '...' + opt.to);
        }
        if (opt.file) {
            command.push('--follow', opt.file);
        }
        'splitter n max-count file from to --pretty format'.split(' ').forEach(function (key) {
            delete opt[key];
        });
        appendOptions(command, opt);
        return this._run(command, responseHandler(next, 'ListLogSummary', splitter, fields));
    }
    /**
     * Clears the queue of pending commands and returns the wrapper instance for chaining.
     *
     * @returns {Git}
     */
    clearQueue() {
        this._runCache.length = 0;
        return this;
    }
    /**
     * Check if a pathname or pathnames are excluded by .gitignore
     *
     * @param {string|string[]} pathnames
     * @param {Function} [then]
     */
    checkIgnore(pathnames, then) {
        const next = trailingFunctionArgument(arguments) || NOOP;
        const command = ['check-ignore', ...asArray(pathnames)];
        return this._run(command, parseCheckIgnore);
        function parseCheckIgnore(err, files) {
            if (err) {
                return next(err);
            }
            next(null, files.split(/\n/g).filter(Boolean).map((file) => file.trim()));
        }
    }
    /**
     * Validates that the current repo is a Git repo.
     *
     * @param {Function} [then]
     */
    checkIsRepo(then) {
        function onError(exitCode, stdErr, done, fail) {
            if (exitCode === 128 && /Not a git repository/i.test(stdErr)) {
                return done(false);
            }
            fail(stdErr);
        }
        function handler(err, isRepo) {
            then && then(err, String(isRepo).trim() === 'true');
        }
        return this._run(['rev-parse', '--is-inside-work-tree'], handler, { onError });
    }
    _rm(_files, option, then) {
        const files = [].concat(_files);
        return this._run(['rm', option, ...files], trailingFunctionArgument(arguments) | NOOP);
    }
}
exports.Git = Git;
/**
 * Given any number of arguments, returns the last argument if it is a function, otherwise returns null.
 * @returns {Function|null}
 */
function trailingFunctionArgument(args) {
    const trailing = args[args.length - 1];
    return (typeof trailing === 'function') ? trailing : null;
}
/**
 * Given any number of arguments, returns the trailing options argument, ignoring a trailing function argument
 * if there is one. When not found, the return value is null.
 * @returns {Object|null}
 */
function trailingOptionsArgument(args) {
    const options = args[(args.length - (trailingFunctionArgument(args) ? 2 : 1))];
    return Object.prototype.toString.call(options) === '[object Object]' ? options : null;
}
/**
 * Given any number of arguments, returns the trailing options array argument, ignoring a trailing function argument
 * if there is one. When not found, the return value is an empty array.
 * @returns {Array}
 */
function trailingArrayArgument(args) {
    const options = args[(args.length - (trailingFunctionArgument(args) ? 2 : 1))];
    return Object.prototype.toString.call(options) === '[object Array]' ? options : [];
}
/**
 * Mutates the supplied command array by merging in properties in the options object. When the
 * value of the item in the options object is a string it will be concatenated to the key as
 * a single `name=value` item, otherwise just the name will be used.
 *
 * @param {string[]} command
 * @param {Object} options
 * @private
 */
function appendOptions(command, options) {
    if (options === null) {
        return;
    }
    Object.keys(options).forEach(function (key) {
        const value = options[key];
        if (typeof value === 'string') {
            return command.push(`${key}=${value}`);
        }
        command.push(key);
    });
}
/**
 * Given the type of response and the callback to receive the parsed response,
 * uses the correct parser and calls back the callback.
 *
 * @param {Function} callback
 * @param {string} type
 * @param {Object...} [args]
 *
 * @private
 */
function responseHandler(callback, type, ...args) {
    if (typeof callback !== 'function') {
        return NOOP;
    }
    return (error, data) => {
        if (error) {
            callback(error, null);
            return;
        }
        const handler = require(`./responses/${type}`);
        const result = handler.parse(...[data, ...args]);
        callback(null, result);
    };
}
function asArray(thing) {
    return [].concat(thing);
}
function validateArgumentType(git, next, method, value, name, required = 'string') {
    const requirements = required.split('|');
    let matched = false;
    for (let i = 0; i < requirements.length && !matched; i++) {
        if (requirements[i] === 'array') {
            matched = Array.isArray(value);
        }
        else {
            matched = typeof value == requirements[i];
        }
    }
    if (!matched) {
        const requiredTypes = requirements.join(' or ');
        return git.exec(() => Git.fail(this, new TypeError(`Git.${method} requires ${name} to be a ${requiredTypes}`), next));
    }
}
//# sourceMappingURL=git.js.map